use moduleinfo::ModuleInfo;
use winapi::*;

pub type Pattern = [(u8, bool)];

fn compare(data: *const u8, pattern: &Pattern) -> bool {
	for i in 0..pattern.len() {
		let (b, m) = pattern[i];

		unsafe {
			if m && *data.offset(i as isize) != b {
				return false;
			}
		}
	}

	true
}

pub fn find(module: &ModuleInfo, pattern: &Pattern) -> Option<LPVOID> {
	if module.size < pattern.len() {
		return None;
	}

	let start = module.base as *const u8;
	let end = module.size - pattern.len();

	for i in 0..end {
		let ptr = unsafe { start.offset(i as isize) };

		if compare(ptr, pattern) {
			return Some(ptr as LPVOID);
		}
	}

	None
}

macro_rules! pattern {
	($name:ident G $size:expr $(; $byte:tt $mask:expr)* , ?? $($rest:tt)*) => (
		pattern!($name G $size + 1 $(; $byte $mask)* ; 0x00 false , $($rest)*);
	);

	($name:ident G $size:expr $(; $byte:tt $mask:expr)* , $b:tt $($rest:tt)*) => (
		pattern!($name G $size + 1 $(; $byte $mask)* ; $b true , $($rest)*);
	);

	($name:ident G $size:expr $(; $byte:tt $mask:expr)+ ,) => (
		pub const $name: [(u8, bool); $size] = [$(($byte, $mask)),*];
	);

	($name:ident $($rest:tt)+) => (
		pattern!($name G 0 , $($rest)*);
	);
}

pattern!(Cbuf_AddText
	0x8B 0x54 0x24 0x04 0x83 0xC9 0xFF 0x57 0x33 0xC0 0x8B 0xFA 0xF2 0xAE 0x8B 0x3D ?? ?? ?? ?? 0xA1 ?? ?? ?? ?? 0xF7 0xD1 0x49 0x03 0xCF 0x3B 0xC8
);

pattern!(Host_Spawn_f
	0xA1 ?? ?? ?? ?? 0x53 0xBB 0x01 0x00 0x00 0x00 0x3B 0xC3 0x56 0x75 0x11 0x68 ?? ?? ?? ?? 0xFF 0x15 ?? ?? ?? ?? 0x83 0xC4 0x04 0x5E 0x5B
);

pattern!(Host_UnPause_f
	0xA0 ?? ?? ?? ?? 0x84 0xC0 0x74 0x59 0x8B 0x0D ?? ?? ?? ?? 0xB8 0x01 0x00 0x00 0x00 0x3B 0xC8 0x75 0x0A 0x50 0xE8
);

pattern!(CHL1GameMovement__CheckJumpButton
	0x83 0xEC 0x14 0x53 0x56 0x8B 0xF1 0x57 0x8B 0x7E 0x08 0x85 0xFF 0x74 0x12 0x8B 0x07 0x8B 0xCF 0xFF 0x90 0x60 0x01 0x00 0x00 0x84 0xC0 0x74 0x04 0x8B 0xCF 0xEB
);
